#pragma once
#include "vec.hpp"

template<typename T, int N, int M>
using tmatnm = tvecn<tvecn<T,M>, N>;

template<typename T, int N>
using tmatn = tmatnm<T,N,N>;

template<typename T>
using tmat4 = tmatn<T,4>;

template<typename T>
using tmat3 = tmatn<T,3>;

using mat4 = tmat4<float>;
using mat3 = tmat3<float>;

template<typename T, int N, int M>
tmatnm<T,M,N> transpose(const tmatnm<T,N,M>& arg)
{
    tmatnm<T,M,N> res;
    for (int i=0; i<M; ++i)
        for (int j=0; j<N; ++j)
            res[i][j] = arg[j][i];
    return res;
}

/* matrix-vector multiplication */
template<typename T, int N, int M>
tvecn<T,N> mult(const tmatnm<T,N,M>& lhs, const tvecn<T,M>& rhs)
{
    tvecn<T,N> res;
    for (int i=0; i<N; ++i)
        res[i] = dot(lhs[i], rhs);
    return res;
}

/* vector-matrix multiplication */
template<typename T, int N, int M>
tvecn<T,M> mult(const tvecn<T,N>& lhs, const tmatnm<T,N,M>& rhs)
{
    tvecn<T,M> res = lhs[0] * rhs[0];
    for (int i=1; i<N; ++i)
        res+= lhs[i] * rhs[i];
    return res;
}

/* matrix-matrix multiplication */
template<typename T, int N, int K, int M>
tmatnm<T,N,M> mult(const tmatnm<T,N,K>& lhs, const tmatnm<T,K,M>& rhs)
{
    tmatnm<T,N,M> res;
    for (int i=1; i<N; ++i)
        res[i] = lhs[i] * rhs;
    return res;
}

mat4 from_cols(const vec3& e0, const vec3& e1, const vec3& e2, const vec3& e3)
{
    mat4 res;
    for (int j=0; j<3; ++j)
        res[j][0] = e0[j];
    for (int j=0; j<3; ++j)
        res[j][1] = e1[j];
    for (int j=0; j<3; ++j)
        res[j][2] = e2[j];
    for (int j=0; j<3; ++j)
        res[j][3] = e3[j];

    for (int j=0; j<3; ++j)
        res[3][j] = 0;   

    res[3][3] = 1.0f;

    return res;
}

mat4 look_at(const vec3& origin, const vec3& target, const vec3& up_world)

/*
    Returns the view matrix generated by look_at (note: view = inv(camera_mat) )
*/

{
    mat3 rot;
    /* forward */
    rot[2] = normalize(target-origin);
    /* right */
    rot[0] = normalize(cross(up_world, rot[2]));
    /* up */
    rot[1] = cross(rot[2], rot[0]);

    /* tformed inv origin, view = inv(T(t)*R) = R^T * T(-t)*/
    rot = transpose(rot);
    vec3 inv_origin = mult(rot, -origin);


    mat4 res = from_cols (rot[0], rot[1], rot[2], inv_origin);

    return res;
}

